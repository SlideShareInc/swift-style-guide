diff --git a/README.md b/README.md
index 175720b..e987178 100644
--- a/README.md
+++ b/README.md
@@ -12,6 +12,10 @@ This is the SlideShare Swift Style Guide we are using for our upcoming iOS 8 onl
 * [Singleton](#singleton)
 * [Collections](#collections)
 * [Optionals](#optionals)
+* [Strings](#strings)
+* [Enums](#enums)
+* [Documentation](#documentation)
+* [Protocols](#protocols)
 
 ---
 
@@ -24,6 +28,9 @@ This is the SlideShare Swift Style Guide we are using for our upcoming iOS 8 onl
 - Switch statements should have each case statement not indented and all code executed for that case indented below:
 
 ```swift
+var value = 2
+var test: String?
+
 switch value {
 case 1:
 	test = "abc"
@@ -32,7 +39,28 @@ default:
 }
 ```
 
-#### Propreties
+- If you want to match multiple values within an object or struct, create a tuple with the two values:
+
+```swift
+struct TestValue {
+	enum Val {
+		case A
+		case B
+	}
+	var value: Val = .A
+	var detail: String = "Test"
+}
+var testValue = TestValue()
+
+switch (testValue.value, testValue.detail) {
+case (.A, "Test"):
+	println("This is printed")
+default:
+	println("This is not printed")
+}
+```
+
+#### Properties
 - If making a read-only computed variable, provide the getter without the get {} around it:
 
 ```swift
@@ -88,6 +116,17 @@ var property = 10 {
 }
 ```
 
+- Class constants are currently not supported, therefore, if you need that functionality, make it a computed variable:
+
+```swift
+class Test {
+	class var ConstantValue: String {
+		return "TestString"
+	}
+}
+```
+	Reasoning: When class constants are supported, the way the constant is accessed will not change.
+
 #### Closures
 - Do not use parameters when declaring parameter names to use in a closure. Also, keep parameter names on same line as opening brace for closures:
 
@@ -150,14 +189,14 @@ func noReturn() {
 
 ```swift
 class Test {
-	
+
 	var a: (() -> Void)?
 	var b: Int = 3
-	
+
 	func foo(a: () -> Void) {
 		self.a = a
 	}
-	
+
 	func foo1() {
 		foo() {
 			println(self.b)
@@ -178,6 +217,23 @@ class var testVar: String
 var someDictionary: [String : Int]
 ```
 
+- When declaring a constant, use camel case with the first letter uppercase.
+
+```swift
+class TestClass {
+	let ConstantValue = 3
+}
+```
+
+- To declare a set of constant variables not be used for switching, use a struct:
+
+```swift
+struct Constants {
+	static let A = "A"
+	static let B = "B"
+}
+```
+
 #### Singleton
 - Implement a singleton by having this at the top of your class definition:
 
@@ -193,19 +249,175 @@ class ClassA {
 ```
 
 #### Collections
-- When appending to an Array or String, always use the append method instead of the += operator. This is because the += operator will not append single elements.
+- When appending to a collection, always use the append method instead of the += operator.
 
 ```swift
 var array = [1, 2, 3]
 array.append(4)
 ```
 
+	Reasoning: The += operator will not append single elements.
+
 #### Optionals
 - When unwrapping optionals, rebind the optional to the same name, unless there is a reason not to. This is example shows this, but in this case it should be done within the binding.
 
 ```swift
-let bike = possibleBike() // this returns an optional
+func possibleBike() -> Bike? {
+	// content
+}
+
+let bike = possibleBike()
 if let bike = bike {
 	// do something with bike
 }
 ```
+
+#### Strings
+- When appending to a string, always use the += operator.
+
+```swift
+var newString = "Hello"
+newString += " world!"
+```
+
+#### Enums
+- When using an enum, always prefer the shorthand syntax when possible. The shorthand syntax should be possible whenever the type does not need to be inferred from the assigned value. Note: there are certain bugs that don't allow them to be used everywhere they should be possible.
+
+```swift
+enum TestEnum {
+	case A
+	case B
+}
+
+var theValue: TestEnum?
+var shouldBeA = true
+
+if shouldBeA {
+	theValue = .A
+} else {
+	theValue = .B
+}
+```
+
+#### Documentation
+- When documenting a method, use /// if it is only a single line
+
+```swift
+/// This method does nothing
+func foo() {
+	// content
+}
+```
+
+- If you are documenting a method, use /\*\* to begin and **/ to end if it is multiline; do not indent.
+
+```swift
+/**
+This method does something.
+It's very useful.
+*/
+func foo2() {
+	// content
+}
+```
+
+- Use the standard Swift Documentation syntax (reST) in order to enable Quick Documentation. Follow the formatting below, exactly.
+
+Note: Make sure to test your documentation by checking it's Quick Documentation by option-clicking on the method name.
+
+```swift
+/**
+This method has parameters and a return type.
+
+:param: input This is an input parameter.
+
+:returns: True if it worked; false otherwise.
+*/
+func foo3(input: String) -> Bool {
+	// content
+}
+```
+
+> **Note: The following section refers to marks, which are Swift's version of #pragma mark in Objective-C to separate code. There are 2 types of marks: section marks and sub-section marks.**
+
+> Section Marks:
+
+>		// MARK: - Section Name
+
+> Sub-section Marks:
+
+>		// MARK: Sub-section Name
+
+- Use marks to indicate new sections in code. Separate the mark comment with a new line.
+
+```swift
+class Stuff {
+
+	// MARK: - Instance methods
+
+	func newMethod() {
+		// content
+	}
+}
+```
+
+- When a class implements a protocol, an extension should be created at the bottom of the file  that declares the protocol conformance and implements the protocol. 1 extension per protocol:
+
+```swift
+// NewProtocol.swift //
+protocol NewProtocol {
+	func reqMethod()
+}
+
+// Test.swift //
+class Test {
+
+	// content
+}
+
+extension Test: NewProtocol {
+	func reqMethod() {
+		// content
+	}
+}
+```
+
+- The class/struct layout should be ordered as follows with respect to marks and code organization (Note: See naming convention specified in above note):
+
+		- Section: Singleton
+		- Section: Declared Types (Enums, Structs, etc.), Typealiases
+		- Section: Constants
+		- Section: Class Properties
+		- Section: Instance Properties
+			- Sub-section: Stored
+			- Sub-section: Computed
+		- Section: Init/Deinit
+		- Section: Class Methods
+			- Sub-section: Public
+			- Sub-section: Private
+		- Section: Instance Methods
+			- Sub-section: Public
+			- Sub-section: Private
+		- Section: <Protocol Name>
+
+#### Protocols
+- Do not use @objc in front of a protocol unless you need to specify optional methods. If declaring a type as a protocol, you will need to add the class keyword:
+
+```swift
+protocol NewProtocol: class {
+	// content
+}
+
+@objc protocol OptionalProtocol {
+	func fooReq()
+	optional func fooOpt()
+}
+
+class NewClass: OptionalProtocol {
+	weak var delegate: NewProtocol?
+
+	func fooReq() {
+
+	}
+}
+```
